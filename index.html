<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Project Cosmic Regression</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/2.0.5/p5.min.js"></script>
</head>
<body>
    <input type="file" id="csvFile">
    <script>
        let values = {x:[[]],y:[]};
        let biases = [];
        let weights = [];
        let threshold = 0.5;
        for (let i = 0; i < values.x[0].length; i++) {
            weights.push(1); // initialize to 1 to avoid division by 0
            biases.push(0);
        }


        const gaussian = (x) => {
            let sum = 0;
            for (let i = 0; i < x.length; i++) {
                sum += Math.pow(x[i] - biases[i], 2) / (2 * weights[i] * weights[i]);
            }
            return Math.exp(-sum);
        }
        const catagorize = (x,t = threshold) => (gaussian(x) >= t ? 1 : 0);

        const lossCalculation = (xVals, yVals) => {
            let losses = 0;
            for (let i = 0; i < xVals.length; i++) {
                losses += -(yVals[i] * Math.log(gaussian(xVals[i]) + 1e-12) + (1 - yVals[i]) * Math.log(1 - gaussian(xVals[i]) + 1e-12));
            }
            return losses / xVals.length;
        }

        const updateRegression = (xVals, yVals) => {
            let dW = [];
            let dB = [];
            for (var i = 0; i < values.x[0].length; i++) {
               dW.push(0);
               dB.push(0);
            }
            for (let i = 0; i < xVals.length; i++) {
                let error = gaussian(xVals[i]) - yVals[i];
                for (let j = 0; j < values.x[0].length; j++) {
                    dB[j] += error * (xVals[i][j] - biases[j]) / (weights[j] * weights[j]);
                    dW[j] += error * Math.pow(xVals[i][j] - biases[j], 2) / (weights[j] * weights[j] * weights[j]);
                }
            }

            for (let j = 0; j < values.x[0].length; j++) {
                dB[j] /= xVals.length;
                dW[j] /= xVals.length;
            }

            return { dB: dB, dW: dW };
        }
        const classification = (xVals, yVals, t = threshold) => {
            let TP = 0, TN = 0, FP = 0, FN = 0;

            for (let i = 0; i < xVals.length; i++) {
                const predicted = catagorize(xVals[i], t); // xVals[i] is now an array
                if (yVals[i] === 1 && predicted === 1) {
                    TP++;
                } else if (yVals[i] === 1 && predicted === 0) {
                    FN++;
                } else if (yVals[i] === 0 && predicted === 1) {
                    FP++;
                } else if (yVals[i] === 0 && predicted === 0) {
                    TN++;
                }
            }
            const tpr = TP / (TP + FN);      // avoid division by zero
            const precision = TP / (TP + FP);
            const fpr = FP / (FP + TN);
            const acc = (TP + TN) / (TP + TN + FP + FN);
            return {TPR: tpr, precision, FPR: fpr, accuracy: acc};
        };

        const train = (epochs, lr) => {
            for (let epoch = 0; epoch < epochs; epoch++) {
                let grads = updateRegression(values.x, values.y);
                for (let j = 0; j < values.x[0].length; j++) {
                    biases[j] -= lr * grads.dB[j];
                    weights[j] -= lr * grads.dW[j];
                }

                if (epoch % (epochs/10) === 0) {
                    console.log("Epoch " + epoch + ": Loss=" + lossCalculation(values.x, values.y).toFixed(4) + " Biases=" + biases.map(v => v.toFixed(2)) + " Weights=" + weights.map(v => v.toFixed(2)));
                }
            }
        }
        const debug = () =>{
            train(1000,0.05);
            console.log("Prediction:" + catagorize([2,3,1]));
            console.log("TPR: " + classification(values.x, values.y).TPR);
            console.log("Precision: " + classification(values.x, values.y).precision);
            console.log("FPR: " + classification(values.x, values.y).FPR);
            console.log("Accuracy: " + classification(values.x, values.y).accuracy);
        }
        function readCSVToXY(file, xCols, yCol, callback) {
        let reader = new FileReader();
        reader.onload = function(e) {
            let data = e.target.result;
            let lines = data.trim().split(/\r?\n/);
            let headers = lines[0].split(',');

            let xIndices = [];
            for (let i = 0; i < xCols.length; i++) {
                xIndices.push(headers.indexOf(xCols[i]));
            }
            let yIndex = headers.indexOf(yCol);

            let x = [];
            let y = [];

            for (let j = 1; j < lines.length; j++) {
                let values = lines[j].split(',');
                let xRow = [];
                for (let k = 0; k < xIndices.length; k++) {
                    xRow.push(values[xIndices[k]]);
                }
                x.push(xRow);
                y.push(values[yIndex]);
            }

            callback({ x: x, y: y });
        };

        reader.readAsText(file);
    }
        document.getElementById('csvFile').addEventListener('change', function(e) {
            let file = e.target.files[0];
            if (!file) return;

            // specify which columns to use
            let xCols = ['koi_period','koi_time0bk','koi_impact','koi_duration','koi_depth','koi_prad'];
            let yCol = 'koi_disposition';

            readCSVToXY(file, xCols, yCol, function(result) {
                console.log(result);
                values = result;
                debug();
            });
        }, false);
        

    </script>
</body>
</html>
