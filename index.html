<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Project Cosmic Regression</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/2.0.5/p5.min.js"></script>
    <style>
        body {
            background-color: black;
        }
        #csvFile {
            display: block;
            margin: 40px auto;
            text-align: center;
            transform: translate(60px);
        }
        </style>

    </style>
</head>
<body>

    <input type="file" id="csvFile">
    <script>
        let values;
        
        let biases = [];
        let weights = [];
        let threshold = 0.5;
        const gaussian = (x) => {
            let sum = 0;
            for (let i = 0; i < x.length; i++) {
                const w = weights[i];
                const b = biases[i];
                const xi = x[i];

                if (isNaN(xi) || isNaN(w) || isNaN(b) || w <= 0) return 1e-6; // fail-safe
                sum += Math.pow(xi - b, 2) / (2 * w * w);
            }

            const result = Math.exp(-sum);
            if (isNaN(result)) return 1e-6;
            return Math.min(Math.max(result, 1e-6), 1 - 1e-6);
        };

        const catagorize = (x,t = threshold) => (gaussian(x) >= t ? 1 : 0);

        const lossCalculation = (xVals, yVals) => {
            let losses = 0;
            for (let i = 0; i < xVals.length; i++) {
                losses += -(yVals[i] * Math.log(gaussian(xVals[i]) + 1e-12) + (1 - yVals[i]) * Math.log(1 - gaussian(xVals[i]) + 1e-12));
            }
            return losses / xVals.length;
        }

        const updateRegression = (xVals, yVals) => {
            const dW = Array(values.x[0].length).fill(0);
            const dB = Array(values.x[0].length).fill(0);

            for (let i = 0; i < xVals.length; i++) {
                const g = gaussian(xVals[i]);
                if (isNaN(g)) continue;

                const error = g - yVals[i];

                for (let j = 0; j < values.x[0].length; j++) {
                    const w = weights[j];
                    const b = biases[j];
                    const xi = xVals[i][j];

                    if (!isFinite(w) || w <= 0 || isNaN(b) || isNaN(xi)) continue;

                    dB[j] += error * (xi - b) / (w * w);
                    dW[j] += error * Math.pow(xi - b, 2) / (w * w * w);
                }
            }

            for (let j = 0; j < values.x[0].length; j++) {
                dB[j] /= xVals.length;
                dW[j] /= xVals.length;
                if (isNaN(dB[j])) dB[j] = 0;
                if (isNaN(dW[j])) dW[j] = 0;
            }

            return { dB, dW };
        };

        const classification = (xVals, yVals, t = threshold) => {
            let TP = 0, TN = 0, FP = 0, FN = 0;

            for (let i = 0; i < xVals.length; i++) {
                const predicted = catagorize(xVals[i], t);
                if (yVals[i] === 1 && predicted === 1) {
                    TP++;
                } else if (yVals[i] === 1 && predicted === 0) {
                    FN++;
                } else if (yVals[i] === 0 && predicted === 1) {
                    FP++;
                } else if (yVals[i] === 0 && predicted === 0) {
                    TN++;
                }
            }
            const tpr = TP / (TP + FN);
            const precision = TP / (TP + FP);
            const fpr = FP / (FP + TN);
            const acc = (TP + TN) / (TP + TN + FP + FN);
            return {TPR: tpr, precision, FPR: fpr, accuracy: acc};
        };
        const calculateROC = (xVals, yVals) => {
            const steps = 100;
            let thresholds = [];
            let tprs = [];
            let fprs = [];
            for (let i = steps; i >= 0; i--) {
                let t = i / steps;
                thresholds.push(t);
                const data = classification(xVals,yVals,t);
                tprs.push(data.TPR);
                fprs.push(data.FPR);
            }
            return {thresholds: thresholds, TPR: tprs, FPR: fprs};
        }
        const calculateAUC = (ROC) => {
            let auc = 0;
            for (let i = 1; i < ROC.TPR.length; i++) {
                let xDiff = ROC.FPR[i] - ROC.FPR[i-1];
                let yAvg = (ROC.TPR[i] + ROC.TPR[i-1]) / 2;
                auc += xDiff * yAvg;
            }
            return auc;
        }
        const train = (epochs, lr) => {
            for (let epoch = 0; epoch < epochs; epoch++) {
                const grads = updateRegression(values.x, values.y);

                for (let j = 0; j < values.x[0].length; j++) {
                    if (isNaN(grads.dB[j]) || isNaN(grads.dW[j])) continue; // skip bad gradients
                    biases[j] -= lr * grads.dB[j];
                    weights[j] -= lr * grads.dW[j];

                    if (!isFinite(weights[j]) || weights[j] <= 0) weights[j] = 1; // clamp
                    if (!isFinite(biases[j])) biases[j] = 0;
                }

                if (epoch % (epochs / 10) === 0) {
                    console.log(
                        `Epoch ${epoch}: Loss=${lossCalculation(values.x, values.y)} ` +
                        `Biases=${biases.map(v => v.toFixed(2))} Weights=${weights.map(v => v.toFixed(2))}`
                    );
                }
            }
        };

        const debug = () =>{
            train(1000,0.05);
            console.log("TPR: " + classification(values.x, values.y).TPR);
            console.log("Precision: " + classification(values.x, values.y).precision);
            console.log("FPR: " + classification(values.x, values.y).FPR);
            console.log("Accuracy: " + classification(values.x, values.y).accuracy);
            console.log("AUC: " + calculateAUC(calculateROC(values.x, values.y)));
        }
        function readCSVToXY(file, xCols, yCol, callback) {
            let reader = new FileReader();
            reader.onload = function(e) {
                let data = e.target.result;
                let lines = data.trim().split(/\r?\n/);
                let headers = lines[0].split(',');

                let xIndices = [];
                for (let i = 0; i < xCols.length; i++) {
                    xIndices.push(headers.indexOf(xCols[i]));
                }
                let yIndex = headers.indexOf(yCol);

                let x = [];
                let y = [];

                for (let j = 1; j < lines.length; j++) {
                    let values = lines[j].split(',');
                    let xRow = [];
                    for (let k = 0; k < xIndices.length; k++) {
                        xRow.push(parseFloat(values[xIndices[k]]));
                    }
                    x.push(xRow);
                    y.push(values[yIndex]);
                }

                callback({ x: x, y: y });
            };

            reader.readAsText(file);
        }
        document.getElementById('csvFile').addEventListener('change', function(e) {
            let file = e.target.files[0];
            if (!file) return;

            // specify which columns to use
            let xCols = ['koi_period','koi_time0bk','koi_impact','koi_duration','koi_depth','koi_prad'];
            let yCol = 'koi_disposition';

            readCSVToXY(file, xCols, yCol, function(result) {
                
                values = result;
                for (let i = 0; i < values.y.length; i++) {
                    if(values.y[i]==="CONFIRMED"){
                        values.y[i] = 1;
                    }else if(values.y[i]==="CANDIDATE"){
                        values.y[i] = 1;
                    }else{
                        values.y[i] = 0;
                    }
                    values.y[i] = Number(values.y[i]);
                }
                for (let i = 0; i < values.x[0].length; i++) {
                    weights.push(1); // initialize to 1 to avoid division by 0
                    biases.push(0);
                }
                console.log(values);
                debug();
            });
        }, false);
        
































        let cnv;
        let period = 0;
        let transitTime = 0;
        let impact = 0;
        let duration = 0;
        let depth = 0;
        let prad = 0;
        let classi = 0;
        let cata = 0;
        function setup() {
            cnv = createCanvas(800, 800);
            cnv.position((windowWidth - width) / 2, 100);
            inp1 = createInput('','number');
            inp1.size(200);
            inp1.position((windowWidth - inp1.width) / 2, 500);
            inp1.input(() => {
                period = parseFloat(inp1.value());
                if (isNaN(period)){
                    period = 0;
                }
            });
            inp2 = createInput('','number');
            inp2.size(200);
            inp2.position((windowWidth - inp2.width) / 2, 550);
            inp2.input(() => {
                transitTime = parseFloat(inp2.value());
                if (isNaN(transitTime)){
                    transitTime = 0;
                }
            });
            inp3 = createInput('','number');
            inp3.size(200);
            inp3.position((windowWidth - inp3.width) / 2, 600);
            inp3.input(() => {
                impact = parseFloat(inp3.value());
                if (isNaN(impact)){
                    impact = 0;
                }
            });
            inp4 = createInput('','number');
            inp4.size(200);
            inp4.position((windowWidth - inp4.width) / 2, 650);
            inp4.input(() => {
                duration = parseFloat(inp4.value());
                if (isNaN(duration)){
                    duration = 0;
                }
            });
            inp5 = createInput('','number');
            inp5.size(200);
            inp5.position((windowWidth - inp5.width) / 2, 700);
            inp5.input(() => {
                depth = parseFloat(inp5.value());
                if (isNaN(depth)){
                    depth = 0;
                }
            });
            inp6 = createInput('','number');
            inp6.size(200);
            inp6.position((windowWidth - inp6.width) / 2, 750);
            inp6.input(() => {
                prad = parseFloat(inp6.value());
                if (isNaN(prad)){
                    prad = 0;
                }
            });

        }
        function draw(){
            background(255);
            line(width/2,0,width/2,height/2);
            textSize(20);
            text("Orbital Period(days):",300,400);
            text("Transit Epoch(BKJD):",300,450);
            text("Impact Parameter:",300,500);
            text("Transit Duration(hours):",300,550);
            text("Transit Depth(ppm):",300,600);
            text("Planetary Radius(Earth rad):",300,650);
            classi = catagorize([period,transitTime,impact,duration,depth,prad]);
            if(classi === 1){
                cata = "CANDIDATE"
            }else{
                cata = "FALSE NEGATIVE"
            }
            text("Classification: " + cata + ", with "+gaussian([period,transitTime,impact,duration,depth,prad])+"% confidence",200,200)
        }













    </script>
</body>
</html>
